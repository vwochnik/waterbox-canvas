<!DOCTYPE html>
<html>
<head>
  <title>{{ title }}</title>
  <style type="text/css">
body {
  font-family: system-ui, -apple-system, BlinkMacSystemFont,
               "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
  font-size: 16px;
  line-height: 1.5;
}
.title {
  text-align: center;
}
.readme {
    word-wrap: break-word;
    color: #1f2328;
    background-color: #ffffff;
    max-width: 720px;
    margin: 0 auto;
    padding: 45px;
}

/* Headers */
.readme h1, .readme h2 {
    padding-bottom: 0.3em;
    border-bottom: 1px solid #d8dee4;
}

.readme h1 { font-size: 2em; margin-top: 24px; margin-bottom: 16px; font-weight: 600; }
.readme h2 { font-size: 1.5em; margin-top: 24px; margin-bottom: 16px; font-weight: 600; }
.readme h3 { font-size: 1.25em; margin-top: 24px; margin-bottom: 16px; font-weight: 600; }

/* Links */
.readme a {
    color: #0969da;
    text-decoration: none;
}

.readme a:hover {
    text-decoration: underline;
}

/* Lists and Paragraphs */
.readme p, .readme ul, .readme ol {
    margin-top: 0;
    margin-bottom: 16px;
}

/* Blockquotes */
.readme blockquote {
    padding: 0 1em;
    color: #636c76;
    border-left: 0.25em solid #d0d7de;
    margin: 0 0 16px 0;
}

/* Code Blocks & Inline Code */
.readme code {
    padding: 0.2em 0.4em;
    margin: 0;
    font-size: 85%;
    white-space: break-spaces;
    background-color: rgba(175, 184, 193, 0.2);
    border-radius: 6px;
    font-family: ui-monospace, SFMono-Regular, SF Mono, Menlo, Consolas, Liberation Mono, monospace;
}

.readme pre {
    padding: 16px;
    overflow: auto;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f6f8fa;
    border-radius: 6px;
    margin-bottom: 16px;
}

.readme pre code {
    background-color: transparent;
    padding: 0;
}

/* Tables */
.readme table {
    border-spacing: 0;
    border-collapse: collapse;
    margin-bottom: 16px;
    width: 100%;
}

.readme table th, .readme table td {
    padding: 6px 13px;
    border: 1px solid #d0d7de;
}

.readme table tr {
    background-color: #ffffff;
    border-top: 1px solid #d8dee4;
}

.readme table tr:nth-child(2n) {
    background-color: #f6f8fa;
}

/* Horizontal Rule */
.readme hr {
    height: 0.25em;
    padding: 0;
    margin: 24px 0;
    background-color: #d8dee4;
    border: 0;
}
.demo {
  background: #efefef;
  display: flex;
  justify-content: center;
  gap: 48px;
  padding: 48px;
}
</style>
</head>
<body>
  <div class="title">
    <h1>{{ title }}</h1>
  </div>
  <div class="demo">
    <canvas id="canvas1"></canvas>
    <canvas id="canvas2"></canvas>
    <canvas id="canvas3"></canvas>
  </div>
  <div class="readme">
    {{ content }}
  </div>
  <script src="waterbox-canvas.js" type="text/javascript"></script>
  <script type="text/javascript">
    const canvas1 = document.getElementById('canvas1');
    const canvas2 = document.getElementById('canvas2');
    const canvas3 = document.getElementById('canvas3');
    let value = 0;
    const interval = 1000 / 15;
    let lastTime = 0;

    const waterbox1 = Waterbox.createWaterbox(canvas1)
      .waterPattern({
        type: "custom",
        creator: getWaterTexture
      })
      .waterColor({
        fill: 'rgba(58, 123, 213, 0.9)',
        stroke: 'rgba(42, 92, 160, 0.9)',
        lighter: 'rgba(90, 149, 224, 0.9)',
        darker: 'rgba(43, 95, 168, 0.9)',
      })
      .frontColor({
        fill: 'rgba(0,0,0,0.0)',
        stroke: 'rgba(255, 255, 255, 0.8)'
      });

    const waterbox2 = Waterbox.createWaterbox(canvas2)
      .backColor({
        fill: 'rgba(80, 80, 111, 1)',
        lighter: 'rgba(80, 80, 111, 1)',
        darker: 'rgba(80, 80, 111, 1)',
        stroke: 'rgba(80, 80, 111, 1)',
      })
      .waterColor({
        fill: 'rgba(176, 68, 188, 0.6)',
        lighter: 'rgba(176, 68, 188, 0.6)',
        darker: 'rgba(176, 68, 188, 0.6)',
        stroke: 'rgba(176, 68, 188, 0.6)',
      })
      .frontColor(undefined)
      .waterPattern({
        type: "predefined",
        name: "grid",
        size: 15,
        alpha: 1.0
      })
      .scale({
        size: 0.2,
        divisions: 5,
      })
      .strokeWidth(3)
      .clipEdges(true);

    const waterbox3 = Waterbox.createWaterbox(canvas3)
      .backColor({
        fill: 'rgba(80, 80, 111, 1)',
        stroke: 'rgba(80, 80, 111, 1)',
      })
      .waterPattern({
        type: "predefined",
        name: "blocky",
        size: 15,
        alpha: 0.4,
      })
      .clipEdges(true);

    requestAnimationFrame(loop);

    function loop(currentTime) {
      requestAnimationFrame(loop);

      const delta = currentTime - lastTime;
      if (delta >= interval) {
        lastTime = currentTime - (delta % interval);

        update();
      }
    }

    function update() {
      waterbox1.value(value).render();
      waterbox2.value((value + 15) % 100).render();
      waterbox3
        .value((value + 70) % 100)
        .waterColor({
          fill: `hsla(${3.6 * value}, 47%, 50%, 0.8)`,
          lighter: `hsla(${3.6 * value}, 47%, 55%, 0.8)`,
          darker: `hsla(${3.6 * value}, 47%, 45%, 0.8)`,
          stroke: `hsla(${3.6 * value}, 47%, 30%, 0.8)`,
        })
        .render();
      value = (value + 1) % 100;
    }

    function getWaterTexture(ctx) {
      const size = 512; // Size of the pattern tile
      const patternCanvas = new OffscreenCanvas(0, 0);
      const pCtx = patternCanvas.getContext('2d');

      patternCanvas.width = size;
      patternCanvas.height = size;

      // 2. Setup ripple style
      pCtx.lineWidth = 1;
      pCtx.lineCap = 'round';

      // 3. Draw "Voronoi-lite" ripples
      // We draw several curved paths to simulate light catching the crest of waves
      for (let i = 0; i < 256; i++) {
        const x = Math.random() * size;
        const y = Math.random() * size;
        const w = 20 + Math.random() * 40;
        const h = 10 + Math.random() * 20;

      pCtx.strokeStyle = 'rgba(255, 255, 255, 0.5)'; // Soft white highlights
        pCtx.beginPath();
        // Drawing an arc or ellipse segment to mimic wave crests
        pCtx.ellipse(x, y, w, h, Math.random() * Math.PI, 0, Math.PI * 0.5);
        pCtx.stroke();

        // Add a smaller, brighter "sparkle" line for depth
        pCtx.strokeStyle = 'rgba(0, 0, 0, 0.5)';
        pCtx.beginPath();
        pCtx.ellipse(x + 2, y + 2, w, h, Math.random() * Math.PI, 0, Math.PI * 0.4);
        pCtx.stroke();
      }

      // 4. Create and return the pattern
      return ctx.createPattern(patternCanvas, 'repeat');
    }
  </script>
</body>
</html>
